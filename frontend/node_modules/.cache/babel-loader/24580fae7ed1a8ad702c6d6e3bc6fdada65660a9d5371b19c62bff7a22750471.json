{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _tslib = require('./_virtual/_tslib.js');\nvar types = require('./types.js');\nvar actionTypes = require('./actionTypes.js');\nvar utils = require('./utils.js');\nvar environment = require('./environment.js');\nvar initEvent = /*#__PURE__*/utils.toSCXMLEvent({\n  type: actionTypes.init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n  if (utils.isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n    if (utils.isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (utils.isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n    if (utils.isFunction(exec)) {\n      actionObject = _tslib.__assign(_tslib.__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = _tslib.__assign(_tslib.__assign(_tslib.__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n  return actionObject;\n}\nvar toActionObjects = function toActionObjects(action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n  var actions = utils.isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return _tslib.__assign(_tslib.__assign({\n    id: utils.isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event, options) {\n  return {\n    type: actionTypes.raise,\n    event: typeof event === 'function' ? event : utils.toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options === null || options === void 0 ? void 0 : options.id\n  };\n}\nfunction resolveRaise(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  };\n  var resolvedEvent = utils.toSCXMLEvent(utils.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n  if (utils.isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = utils.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = utils.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    type: actionTypes.raise,\n    _event: resolvedEvent,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @deprecated Use the `sendTo(...)` action creator instead.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: actionTypes.send,\n    event: utils.isFunction(event) ? event : utils.toEventObject(event),\n    delay: options ? options.delay : undefined,\n    // TODO: don't auto-generate IDs here like that\n    // there is too big chance of the ID collision\n    id: options && options.id !== undefined ? options.id : utils.isFunction(event) ? event.name : utils.getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = utils.toSCXMLEvent(utils.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n  if (utils.isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = utils.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = utils.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n  var resolvedTarget = utils.isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: types.SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\nfunction sendTo(actor, event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(actionTypes.update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: function to(_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function defaultLogExpr(context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n  return {\n    type: actionTypes.log,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function resolveLog(action, ctx, _event) {\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    value: utils.isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function cancel(sendId) {\n  return {\n    type: actionTypes.cancel,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: types.ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = utils.isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: types.ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = utils.isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: types.ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function assign(assignment) {\n  return {\n    type: actionTypes.assign,\n    assignment: assignment\n  };\n};\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(types.ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = \"\".concat(types.ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(types.ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = \"\".concat(types.ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: types.ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  if (!environment.IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n    target = function target() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, _tslib.__spreadArray([], _tslib.__read(args), false)) : originalTarget_1;\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n      return resolvedTarget;\n    };\n  }\n  return send(function (_, event) {\n    return event;\n  }, _tslib.__assign(_tslib.__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: actionTypes.error,\n      data: utils.isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, _tslib.__assign(_tslib.__assign({}, options), {\n    to: types.SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: types.ActionTypes.Choose,\n    conds: conds\n  };\n}\nvar pluckAssigns = function pluckAssigns(actionBlocks) {\n  var e_1, _a;\n  var assignActions = [];\n  try {\n    for (var actionBlocks_1 = _tslib.__values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n      while (i < block.actions.length) {\n        if (block.actions[i].type === actionTypes.assign) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return assignActions;\n};\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? utils.updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n  function handleAction(blockType, actionObject) {\n    var _a;\n    switch (actionObject.type) {\n      case actionTypes.raise:\n        {\n          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);\n          if (predictableExec && typeof raisedAction.delay === 'number') {\n            predictableExec(raisedAction, updatedContext, _event);\n          }\n          return raisedAction;\n        }\n      case actionTypes.send:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!environment.IS_PRODUCTION) {\n          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here\n\n          utils.warn(!utils.isString(configuredDelay) || typeof sendAction.delay === 'number',\n          // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(configuredDelay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n        if (predictableExec && sendAction.to !== types.SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n        return sendAction;\n      case actionTypes.log:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n      case actionTypes.choose:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = utils.toGuard(condition.cond, machine.options.guards);\n            return !guard || utils.evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n          if (!matchedActions) {\n            return [];\n          }\n          var _b = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, [{\n              type: blockType,\n              actions: toActionObjects(utils.toArray(matchedActions), machine.options.actions)\n            }], predictableExec, preserveActionOrder), 2),\n            resolvedActionsFromChoose = _b[0],\n            resolvedContextFromChoose = _b[1];\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n      case actionTypes.pure:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n          if (!matchedActions) {\n            return [];\n          }\n          var _c = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, [{\n              type: blockType,\n              actions: toActionObjects(utils.toArray(matchedActions), machine.options.actions)\n            }], predictableExec, preserveActionOrder), 2),\n            resolvedActionsFromPure = _c[0],\n            resolvedContext = _c[1];\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n      case actionTypes.stop:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n      case actionTypes.assign:\n        {\n          updatedContext = utils.updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n          var wrapped = _tslib.__assign(_tslib.__assign({}, resolvedActionObject), {\n            exec: function exec(_ctx) {\n              var args = [];\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n              exec_1.apply(void 0, _tslib.__spreadArray([preservedContexts[contextIndex_1]], _tslib.__read(args), false));\n            }\n          });\n          resolvedActionObject = wrapped;\n        }\n        return resolvedActionObject;\n    }\n  }\n  function processBlock(block) {\n    var e_2, _a;\n    var resolvedActions = [];\n    try {\n      for (var _b = _tslib.__values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n  var resolvedActions = utils.flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\nexports.actionTypes = actionTypes;\nexports.after = after;\nexports.assign = assign;\nexports.cancel = cancel;\nexports.choose = choose;\nexports.done = done;\nexports.doneInvoke = doneInvoke;\nexports.error = error;\nexports.escalate = escalate;\nexports.forwardTo = forwardTo;\nexports.getActionFunction = getActionFunction;\nexports.initEvent = initEvent;\nexports.isActionObject = isActionObject;\nexports.log = log;\nexports.pure = pure;\nexports.raise = raise;\nexports.resolveActions = resolveActions;\nexports.resolveLog = resolveLog;\nexports.resolveRaise = resolveRaise;\nexports.resolveSend = resolveSend;\nexports.resolveStop = resolveStop;\nexports.respond = respond;\nexports.send = send;\nexports.sendParent = sendParent;\nexports.sendTo = sendTo;\nexports.sendUpdate = sendUpdate;\nexports.start = start;\nexports.stop = stop;\nexports.toActionObject = toActionObject;\nexports.toActionObjects = toActionObjects;\nexports.toActivityDefinition = toActivityDefinition;","map":{"version":3,"names":["Object","defineProperty","exports","value","_tslib","require","types","actionTypes","utils","environment","initEvent","toSCXMLEvent","type","init","getActionFunction","actionType","actionFunctionMap","undefined","toActionObject","action","actionObject","isString","exec","isFunction","name","toString","__assign","toActionObjects","actions","isArray","map","subAction","toActivityDefinition","id","raise","event","options","toEventObject","delay","resolveRaise","ctx","_event","delaysMap","meta","resolvedEvent","data","resolvedDelay","configDelay","send","to","getEventType","resolveSend","resolvedTarget","sendParent","SpecialTargets","Parent","sendTo","actor","sendUpdate","update","respond","_","__","_a","origin","defaultLogExpr","context","log","expr","label","resolveLog","cancel","sendId","start","activity","activityDef","ActionTypes","Start","stop","actorRef","Stop","resolveStop","actorRefOrString","resolvedActorRef","assign","assignment","isActionObject","after","delayRef","idSuffix","concat","After","done","DoneState","eventObject","doneInvoke","DoneInvoke","error","ErrorPlatform","pure","getActions","Pure","get","forwardTo","target","IS_PRODUCTION","originalTarget_1","args","_i","arguments","length","apply","__spreadArray","__read","Error","escalate","errorData","choose","conds","Choose","pluckAssigns","actionBlocks","e_1","assignActions","actionBlocks_1","__values","actionBlocks_1_1","next","block","i","push","splice","e_1_1","return","call","resolveActions","machine","currentState","currentContext","predictableExec","preserveActionOrder","updatedContext","updateContext","preservedContexts","deferredToBlockEnd","handleAction","blockType","raisedAction","delays","sendAction","configuredDelay","warn","Internal","resolved","chooseAction","matchedActions","find","condition","guard","toGuard","cond","guards","evaluateGuard","_b","toArray","resolvedActionsFromChoose","resolvedContextFromChoose","_c","resolvedActionsFromPure","resolvedContext","resolvedActionObject","exec_1","contextIndex_1","wrapped","_ctx","processBlock","e_2","resolvedActions","e_2_1","forEach","flatten"],"sources":["B:/dev/3DModelViewer/frontend/node_modules/xstate/lib/actions.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _tslib = require('./_virtual/_tslib.js');\nvar types = require('./types.js');\nvar actionTypes = require('./actionTypes.js');\nvar utils = require('./utils.js');\nvar environment = require('./environment.js');\n\nvar initEvent = /*#__PURE__*/utils.toSCXMLEvent({\n  type: actionTypes.init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (utils.isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (utils.isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (utils.isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (utils.isFunction(exec)) {\n      actionObject = _tslib.__assign(_tslib.__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = _tslib.__assign(_tslib.__assign(_tslib.__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = utils.isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return _tslib.__assign(_tslib.__assign({\n    id: utils.isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event, options) {\n  return {\n    type: actionTypes.raise,\n    event: typeof event === 'function' ? event : utils.toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options === null || options === void 0 ? void 0 : options.id\n  };\n}\nfunction resolveRaise(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  };\n  var resolvedEvent = utils.toSCXMLEvent(utils.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (utils.isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = utils.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = utils.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    type: actionTypes.raise,\n    _event: resolvedEvent,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @deprecated Use the `sendTo(...)` action creator instead.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: actionTypes.send,\n    event: utils.isFunction(event) ? event : utils.toEventObject(event),\n    delay: options ? options.delay : undefined,\n    // TODO: don't auto-generate IDs here like that\n    // there is too big chance of the ID collision\n    id: options && options.id !== undefined ? options.id : utils.isFunction(event) ? event.name : utils.getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = utils.toSCXMLEvent(utils.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (utils.isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = utils.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = utils.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = utils.isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: types.SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\nfunction sendTo(actor, event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(actionTypes.update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, _tslib.__assign(_tslib.__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: actionTypes.log,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function (action, ctx, _event) {\n  return _tslib.__assign(_tslib.__assign({}, action), {\n    value: utils.isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function (sendId) {\n  return {\n    type: actionTypes.cancel,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: types.ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = utils.isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: types.ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = utils.isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: types.ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function (assignment) {\n  return {\n    type: actionTypes.assign,\n    assignment: assignment\n  };\n};\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(types.ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = \"\".concat(types.ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(types.ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = \"\".concat(types.ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: types.ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  if (!environment.IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n\n    target = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, _tslib.__spreadArray([], _tslib.__read(args), false)) : originalTarget_1;\n\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n\n      return resolvedTarget;\n    };\n  }\n\n  return send(function (_, event) {\n    return event;\n  }, _tslib.__assign(_tslib.__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: actionTypes.error,\n      data: utils.isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, _tslib.__assign(_tslib.__assign({}, options), {\n    to: types.SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: types.ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nvar pluckAssigns = function (actionBlocks) {\n  var e_1, _a;\n\n  var assignActions = [];\n\n  try {\n    for (var actionBlocks_1 = _tslib.__values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n\n      while (i < block.actions.length) {\n        if (block.actions[i].type === actionTypes.assign) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return assignActions;\n};\n\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? utils.updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n\n  function handleAction(blockType, actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case actionTypes.raise:\n        {\n          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);\n\n          if (predictableExec && typeof raisedAction.delay === 'number') {\n            predictableExec(raisedAction, updatedContext, _event);\n          }\n\n          return raisedAction;\n        }\n\n      case actionTypes.send:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!environment.IS_PRODUCTION) {\n          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here\n\n          utils.warn(!utils.isString(configuredDelay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(configuredDelay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n\n        if (predictableExec && sendAction.to !== types.SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n\n        return sendAction;\n\n      case actionTypes.log:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n\n      case actionTypes.choose:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = utils.toGuard(condition.cond, machine.options.guards);\n            return !guard || utils.evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _b = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(utils.toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromChoose = _b[0],\n              resolvedContextFromChoose = _b[1];\n\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n\n      case actionTypes.pure:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _c = _tslib.__read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(utils.toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromPure = _c[0],\n              resolvedContext = _c[1];\n\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n\n      case actionTypes.stop:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n\n      case actionTypes.assign:\n        {\n          updatedContext = utils.updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n\n          var wrapped = _tslib.__assign(_tslib.__assign({}, resolvedActionObject), {\n            exec: function (_ctx) {\n              var args = [];\n\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n\n              exec_1.apply(void 0, _tslib.__spreadArray([preservedContexts[contextIndex_1]], _tslib.__read(args), false));\n            }\n          });\n\n          resolvedActionObject = wrapped;\n        }\n\n        return resolvedActionObject;\n    }\n  }\n\n  function processBlock(block) {\n    var e_2, _a;\n\n    var resolvedActions = [];\n\n    try {\n      for (var _b = _tslib.__values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n\n  var resolvedActions = utils.flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\n\nexports.actionTypes = actionTypes;\nexports.after = after;\nexports.assign = assign;\nexports.cancel = cancel;\nexports.choose = choose;\nexports.done = done;\nexports.doneInvoke = doneInvoke;\nexports.error = error;\nexports.escalate = escalate;\nexports.forwardTo = forwardTo;\nexports.getActionFunction = getActionFunction;\nexports.initEvent = initEvent;\nexports.isActionObject = isActionObject;\nexports.log = log;\nexports.pure = pure;\nexports.raise = raise;\nexports.resolveActions = resolveActions;\nexports.resolveLog = resolveLog;\nexports.resolveRaise = resolveRaise;\nexports.resolveSend = resolveSend;\nexports.resolveStop = resolveStop;\nexports.respond = respond;\nexports.send = send;\nexports.sendParent = sendParent;\nexports.sendTo = sendTo;\nexports.sendUpdate = sendUpdate;\nexports.start = start;\nexports.stop = stop;\nexports.toActionObject = toActionObject;\nexports.toActionObjects = toActionObjects;\nexports.toActivityDefinition = toActivityDefinition;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}