{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _tslib = require('./_virtual/_tslib.js');\nvar utils = require('./utils.js');\nvar serviceScope = require('./serviceScope.js');\nfunction createNullActor(id) {\n  var _a;\n  return _a = {\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, _a[utils.symbolObservable] = function () {\n    return this;\n  }, _a;\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n  var invokeSrc = utils.toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? utils.mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n  if (utils.isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = serviceScope.provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n  return tempActor;\n}\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now\n\nfunction toActorRef(actorRefLike) {\n  var _a;\n  return _tslib.__assign((_a = {\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, _a[utils.symbolObservable] = function () {\n    return this;\n  }, _a), actorRefLike);\n}\nexports.createDeferredActor = createDeferredActor;\nexports.createInvocableActor = createInvocableActor;\nexports.createNullActor = createNullActor;\nexports.isActor = isActor;\nexports.isSpawnedActor = isSpawnedActor;\nexports.toActorRef = toActorRef;","map":{"version":3,"names":["Object","defineProperty","exports","value","_tslib","require","utils","serviceScope","createNullActor","id","_a","send","subscribe","unsubscribe","getSnapshot","undefined","toJSON","symbolObservable","createInvocableActor","invokeDefinition","machine","context","_event","invokeSrc","toInvokeSource","src","serviceCreator","options","services","type","resolvedData","data","mapContext","tempActor","createDeferredActor","meta","entity","deferred","isMachine","initialState_1","state","provide","withContext","initialState","isActor","item","e","isSpawnedActor","toActorRef","actorRefLike","__assign"],"sources":["B:/dev/3DModelViewer/frontend/node_modules/xstate/lib/Actor.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _tslib = require('./_virtual/_tslib.js');\nvar utils = require('./utils.js');\nvar serviceScope = require('./serviceScope.js');\n\nfunction createNullActor(id) {\n  var _a;\n\n  return _a = {\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, _a[utils.symbolObservable] = function () {\n    return this;\n  }, _a;\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n\n  var invokeSrc = utils.toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? utils.mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n\n  if (utils.isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = serviceScope.provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n\n  return tempActor;\n}\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now\n\nfunction toActorRef(actorRefLike) {\n  var _a;\n\n  return _tslib.__assign((_a = {\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, _a[utils.symbolObservable] = function () {\n    return this;\n  }, _a), actorRefLike);\n}\n\nexports.createDeferredActor = createDeferredActor;\nexports.createInvocableActor = createInvocableActor;\nexports.createNullActor = createNullActor;\nexports.isActor = isActor;\nexports.isSpawnedActor = isSpawnedActor;\nexports.toActorRef = toActorRef;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}