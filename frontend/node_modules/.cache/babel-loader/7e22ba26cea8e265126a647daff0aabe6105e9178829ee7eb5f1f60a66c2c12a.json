{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\nfunction isService(actor) {\n  return 'state' in actor && 'machine' in actor;\n}\nvar defaultCompare = function defaultCompare(a, b) {\n  return a === b;\n};\nvar defaultGetSnapshot = function defaultGetSnapshot(a) {\n  return isService(a) ? getServiceSnapshot(a) : isActorWithState(a) ? a.state : undefined;\n};\nexport function useSelector(actor, selector, compare, getSnapshot) {\n  if (compare === void 0) {\n    compare = defaultCompare;\n  }\n  if (getSnapshot === void 0) {\n    getSnapshot = defaultGetSnapshot;\n  }\n  var latestSelectorRef = useRef(selector);\n  var subscription = useMemo(function () {\n    var snapshot = getSnapshot(actor);\n    var current = selector(snapshot);\n    var notifySubscriber;\n    return {\n      getSnapshot: function getSnapshot() {\n        return snapshot;\n      },\n      getCurrentValue: function getCurrentValue() {\n        return current;\n      },\n      setCurrentValue: function setCurrentValue(newCurrent) {\n        current = newCurrent;\n        notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n      },\n      subscribe: function subscribe(callback) {\n        notifySubscriber = callback;\n        var sub = actor.subscribe(function (emitted) {\n          snapshot = emitted;\n          var next = latestSelectorRef.current(emitted);\n          if (!compare(current, next)) {\n            current = next;\n            callback();\n          }\n        });\n        return function () {\n          sub.unsubscribe();\n        };\n      }\n    };\n    // intentionally omit `getSnapshot` and `compare`\n    // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n    // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n  }, [actor]);\n  var currentSelected = useSubscription(subscription);\n  var currentChanged = false;\n  if (latestSelectorRef.current !== selector) {\n    var selected = selector(subscription.getSnapshot());\n    if (!compare(currentSelected, selected)) {\n      currentChanged = true;\n      currentSelected = selected;\n    }\n  }\n  useIsomorphicLayoutEffect(function () {\n    latestSelectorRef.current = selector;\n    // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n    if (currentChanged) {\n      // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n      // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n      subscription.setCurrentValue(currentSelected);\n    }\n  });\n  return currentSelected;\n}","map":{"version":3,"names":["useMemo","useRef","useSubscription","useIsomorphicLayoutEffect","isActorWithState","getServiceSnapshot","isService","actor","defaultCompare","a","b","defaultGetSnapshot","state","undefined","useSelector","selector","compare","getSnapshot","latestSelectorRef","subscription","snapshot","current","notifySubscriber","getCurrentValue","setCurrentValue","newCurrent","subscribe","callback","sub","emitted","next","unsubscribe","currentSelected","currentChanged","selected"],"sources":["B:/dev/3DModelViewer/frontend/node_modules/react-spring-bottom-sheet/node_modules/@xstate/react/es/useSelector.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nimport { useSubscription } from 'use-subscription';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport { isActorWithState } from './useActor';\nimport { getServiceSnapshot } from './useService';\nfunction isService(actor) {\n    return 'state' in actor && 'machine' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nexport function useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var latestSelectorRef = useRef(selector);\n    var subscription = useMemo(function () {\n        var snapshot = getSnapshot(actor);\n        var current = selector(snapshot);\n        var notifySubscriber;\n        return {\n            getSnapshot: function () { return snapshot; },\n            getCurrentValue: function () { return current; },\n            setCurrentValue: function (newCurrent) {\n                current = newCurrent;\n                notifySubscriber === null || notifySubscriber === void 0 ? void 0 : notifySubscriber();\n            },\n            subscribe: function (callback) {\n                notifySubscriber = callback;\n                var sub = actor.subscribe(function (emitted) {\n                    snapshot = emitted;\n                    var next = latestSelectorRef.current(emitted);\n                    if (!compare(current, next)) {\n                        current = next;\n                        callback();\n                    }\n                });\n                return function () {\n                    sub.unsubscribe();\n                };\n            }\n        };\n        // intentionally omit `getSnapshot` and `compare`\n        // - `getSnapshot`: it is only supposed to read the \"initial\" snapshot of an actor\n        // - `compare`: is really supposed to be idempotent and the same throughout the lifetime of this hook (the same assumption is made in React Redux v7)\n    }, [actor]);\n    var currentSelected = useSubscription(subscription);\n    var currentChanged = false;\n    if (latestSelectorRef.current !== selector) {\n        var selected = selector(subscription.getSnapshot());\n        if (!compare(currentSelected, selected)) {\n            currentChanged = true;\n            currentSelected = selected;\n        }\n    }\n    useIsomorphicLayoutEffect(function () {\n        latestSelectorRef.current = selector;\n        // this condition should not be required, but setState bailouts are currently buggy: https://github.com/facebook/react/issues/22654\n        if (currentChanged) {\n            // required so we don't cause a rerender by setting state (this could create infinite rerendering loop with inline selectors)\n            // at the same time we need to update the value within the subscription so new emits can compare against what has been returned to the user as current value\n            subscription.setCurrentValue(currentSelected);\n        }\n    });\n    return currentSelected;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}